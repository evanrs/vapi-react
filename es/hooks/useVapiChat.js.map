{"version":3,"file":"useVapiChat.js","sources":["../../src/hooks/useVapiChat.ts"],"sourcesContent":["import { useState, useCallback, useRef, useEffect } from 'react';\nimport type { AssistantOverrides } from '../utils/vapiChatClient';\nimport {\n  VapiChatClient,\n  extractContentFromPath,\n} from '../utils/vapiChatClient';\n\nexport interface ChatMessage {\n  id?: string;\n  sessionId?: string;\n  role: 'user' | 'assistant' | 'tool';\n  content: string;\n  timestamp: Date;\n}\n\nexport interface VapiChatState {\n  messages: ChatMessage[];\n  isTyping: boolean;\n  isLoading: boolean;\n  sessionId?: string;\n}\n\nexport interface VapiChatHandlers {\n  sendMessage: (text: string, sessionEnd?: boolean) => Promise<void>;\n  clearMessages: () => void;\n}\n\nexport interface UseVapiChatOptions {\n  enabled?: boolean;\n  publicKey?: string;\n  assistantId?: string;\n  assistantOverrides?: AssistantOverrides;\n  apiUrl?: string;\n  sessionId?: string;\n  firstChatMessage?: string;\n  onMessage?: (message: ChatMessage) => void;\n  onError?: (error: Error) => void;\n}\n\nexport const validateChatInput = (\n  text: string,\n  enabled: boolean,\n  publicKey?: string,\n  assistantId?: string,\n  client?: VapiChatClient | null\n): void => {\n  if (!enabled || !text.trim()) {\n    throw new Error('Chat is disabled or message is empty');\n  }\n\n  if (!publicKey || !assistantId) {\n    throw new Error(\n      'Missing required configuration: publicKey and assistantId'\n    );\n  }\n\n  if (!client) {\n    throw new Error('Chat client not initialized');\n  }\n};\n\nexport const createUserMessage = (text: string): ChatMessage => ({\n  role: 'user',\n  content: text.trim(),\n  timestamp: new Date(),\n});\n\nexport const createAssistantMessage = (content: string): ChatMessage => ({\n  role: 'assistant',\n  content,\n  timestamp: new Date(),\n});\n\nexport const resetAssistantMessageTracking = (\n  currentAssistantMessageRef: React.MutableRefObject<string>,\n  assistantMessageIndexRef: React.MutableRefObject<number | null>\n): void => {\n  currentAssistantMessageRef.current = '';\n  assistantMessageIndexRef.current = null;\n};\n\nexport const preallocateAssistantMessage = (\n  assistantMessageIndexRef: React.MutableRefObject<number | null>,\n  setMessages: React.Dispatch<React.SetStateAction<ChatMessage[]>>\n): void => {\n  // Pre-allocate the assistant message slot\n  setMessages((prev) => {\n    const newMessages = [...prev];\n    assistantMessageIndexRef.current = newMessages.length; // Set index BEFORE adding\n    newMessages.push({\n      role: 'assistant',\n      content: '', // Start with empty content\n      timestamp: new Date(),\n    });\n    return newMessages;\n  });\n};\n\nexport const handleStreamError = (\n  error: Error,\n  setIsTyping: (typing: boolean) => void,\n  assistantMessageIndexRef: React.MutableRefObject<number | null>,\n  onError?: (error: Error) => void\n): void => {\n  console.error('Stream error:', error);\n  setIsTyping(false);\n  assistantMessageIndexRef.current = null;\n  onError?.(error);\n};\n\nexport const handleStreamChunk = (\n  chunk: any,\n  sessionId: string | undefined,\n  setSessionId: (id: string | undefined) => void,\n  currentAssistantMessageRef: React.MutableRefObject<string>,\n  assistantMessageIndexRef: React.MutableRefObject<number | null>,\n  setMessages: React.Dispatch<React.SetStateAction<ChatMessage[]>>\n): void => {\n  // Update sessionId if provided in response\n  if (chunk.sessionId && chunk.sessionId !== sessionId) {\n    setSessionId(chunk.sessionId);\n  }\n\n  const content = extractContentFromPath(chunk);\n  if (content) {\n    currentAssistantMessageRef.current += content;\n\n    // Since we pre-allocated, we know the index is always valid\n    if (assistantMessageIndexRef.current !== null) {\n      const targetIndex = assistantMessageIndexRef.current!;\n      setMessages((prev) => {\n        const newMessages = [...prev];\n\n        if (targetIndex < newMessages.length) {\n          newMessages[targetIndex] = {\n            ...newMessages[targetIndex],\n            content: currentAssistantMessageRef.current,\n          };\n        }\n\n        return newMessages;\n      });\n    }\n  }\n};\n\nexport const handleStreamComplete = (\n  setIsTyping: (typing: boolean) => void,\n  assistantMessageIndexRef: React.MutableRefObject<number | null>,\n  currentAssistantMessageRef: React.MutableRefObject<string>,\n  onMessage?: (message: ChatMessage) => void\n): void => {\n  setIsTyping(false);\n  assistantMessageIndexRef.current = null;\n\n  if (currentAssistantMessageRef.current) {\n    const finalMessage = createAssistantMessage(\n      currentAssistantMessageRef.current\n    );\n    onMessage?.(finalMessage);\n  }\n};\n\nexport const useVapiChat = ({\n  enabled = true,\n  publicKey,\n  assistantId,\n  assistantOverrides,\n  apiUrl,\n  sessionId: initialSessionId,\n  firstChatMessage,\n  onMessage,\n  onError,\n}: UseVapiChatOptions): VapiChatState &\n  VapiChatHandlers & { isEnabled: boolean } => {\n  const [messages, setMessages] = useState<ChatMessage[]>(() => {\n    if (enabled && firstChatMessage) {\n      return [\n        {\n          role: 'assistant',\n          content: firstChatMessage,\n          timestamp: new Date(),\n        },\n      ];\n    }\n    return [];\n  });\n  const [isTyping, setIsTyping] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [sessionId, setSessionId] = useState<string | undefined>(\n    initialSessionId\n  );\n\n  const clientRef = useRef<VapiChatClient | null>(null);\n  const abortFnRef = useRef<(() => void) | null>(null);\n  const currentAssistantMessageRef = useRef<string>(''); // Accumulates assistant message content\n  const assistantMessageIndexRef = useRef<number | null>(null); // Tracks array position\n  const isEndingSessionRef = useRef<boolean>(false);\n\n  useEffect(() => {\n    if (publicKey && enabled) {\n      clientRef.current = new VapiChatClient({ publicKey, apiUrl });\n    }\n\n    return () => {\n      // Cleanup: abort any ongoing stream\n      abortFnRef.current?.();\n    };\n  }, [publicKey, apiUrl, enabled]);\n\n  // Update sessionId if initialSessionId changes\n  useEffect(() => {\n    if (initialSessionId) {\n      setSessionId(initialSessionId);\n    }\n  }, [initialSessionId]);\n\n  const addMessage = useCallback(\n    (message: ChatMessage) => {\n      setMessages((prev) => [...prev, message]);\n      onMessage?.(message);\n    },\n    [onMessage]\n  );\n\n  const sendMessage = useCallback(\n    async (text: string, sessionEnd: boolean = false) => {\n      try {\n        if (sessionEnd) {\n          if (isEndingSessionRef.current) {\n            return; // IMP: Prevent duplicate end-session sends\n          }\n          isEndingSessionRef.current = true;\n        }\n\n        validateChatInput(\n          text,\n          enabled,\n          publicKey,\n          assistantId,\n          clientRef.current\n        );\n\n        setIsLoading(true);\n\n        if (!sessionEnd && text.trim()) {\n          const userMessage = createUserMessage(text);\n          addMessage(userMessage);\n        }\n\n        if (!sessionEnd) {\n          resetAssistantMessageTracking(\n            currentAssistantMessageRef,\n            assistantMessageIndexRef\n          );\n          preallocateAssistantMessage(assistantMessageIndexRef, setMessages);\n          setIsTyping(true);\n        } else {\n          const endingText = text.trim() || 'Ending chat...';\n          setMessages((prev) => [\n            ...prev,\n            {\n              role: 'assistant',\n              content: endingText,\n              timestamp: new Date(),\n            },\n          ]);\n          setIsTyping(true);\n        }\n\n        const onStreamError = (error: Error) =>\n          handleStreamError(\n            error,\n            setIsTyping,\n            assistantMessageIndexRef,\n            onError\n          );\n\n        const onChunk = (chunk: any) =>\n          handleStreamChunk(\n            chunk,\n            sessionId,\n            setSessionId,\n            currentAssistantMessageRef,\n            assistantMessageIndexRef,\n            setMessages\n          );\n\n        const onComplete = sessionEnd\n          ? () => {\n              setIsTyping(false);\n              assistantMessageIndexRef.current = null;\n            }\n          : () =>\n              handleStreamComplete(\n                setIsTyping,\n                assistantMessageIndexRef,\n                currentAssistantMessageRef,\n                onMessage\n              );\n\n        let input: string | Array<{ role: string; content: string }>;\n        if (sessionEnd) {\n          input = text.trim();\n        } else {\n          if (\n            firstChatMessage &&\n            firstChatMessage.trim() !== '' &&\n            messages.length === 1 &&\n            messages[0].role === 'assistant'\n          ) {\n            input = [\n              {\n                role: 'assistant',\n                content: firstChatMessage,\n              },\n              {\n                role: 'user',\n                content: text.trim(),\n              },\n            ];\n          } else {\n            input = text.trim();\n          }\n        }\n\n        const abort = await clientRef.current!.streamChat(\n          {\n            input,\n            assistantId: assistantId!,\n            assistantOverrides,\n            sessionId,\n            stream: true,\n            sessionEnd,\n          },\n          onChunk,\n          onStreamError,\n          onComplete\n        );\n\n        abortFnRef.current = abort;\n      } catch (error) {\n        console.error('Error sending message:', error);\n        setIsTyping(false);\n        assistantMessageIndexRef.current = null;\n        onError?.(error as Error);\n        throw error;\n      } finally {\n        setIsLoading(false);\n        if (sessionEnd) {\n          isEndingSessionRef.current = false;\n        }\n      }\n    },\n    [\n      enabled,\n      publicKey,\n      assistantId,\n      assistantOverrides,\n      sessionId,\n      addMessage,\n      onError,\n      onMessage,\n      firstChatMessage,\n      messages,\n    ]\n  );\n\n  const clearMessages = useCallback(() => {\n    // Reset to firstChatMessage if provided, otherwise empty array\n    if (enabled && firstChatMessage) {\n      setMessages([\n        {\n          role: 'assistant',\n          content: firstChatMessage,\n          timestamp: new Date(),\n        },\n      ]);\n    } else {\n      setMessages([]);\n    }\n\n    // Abort any ongoing stream\n    abortFnRef.current?.();\n    setIsTyping(false);\n    setIsLoading(false);\n\n    // Reset assistant message tracking\n    resetAssistantMessageTracking(\n      currentAssistantMessageRef,\n      assistantMessageIndexRef\n    );\n\n    // Clear sessionId when clearing messages to start fresh\n    setSessionId(undefined);\n  }, [enabled, firstChatMessage]);\n\n  return {\n    // State\n    messages,\n    isTyping,\n    isLoading,\n    sessionId,\n    isEnabled: enabled,\n\n    // Handlers\n    sendMessage,\n    clearMessages,\n  };\n};\n"],"names":["validateChatInput","text","enabled","publicKey","assistantId","client","createUserMessage","createAssistantMessage","content","resetAssistantMessageTracking","currentAssistantMessageRef","assistantMessageIndexRef","preallocateAssistantMessage","setMessages","prev","newMessages","handleStreamError","error","setIsTyping","onError","handleStreamChunk","chunk","sessionId","setSessionId","extractContentFromPath","targetIndex","handleStreamComplete","onMessage","finalMessage","useVapiChat","assistantOverrides","apiUrl","initialSessionId","firstChatMessage","messages","useState","isTyping","isLoading","setIsLoading","clientRef","useRef","abortFnRef","isEndingSessionRef","useEffect","VapiChatClient","addMessage","useCallback","message","sendMessage","sessionEnd","userMessage","endingText","onStreamError","onChunk","onComplete","input","abort","clearMessages"],"mappings":"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"}