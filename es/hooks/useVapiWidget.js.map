{"version":3,"file":"useVapiWidget.js","sources":["../../src/hooks/useVapiWidget.ts"],"sourcesContent":["import { useState, useCallback } from 'react';\nimport type { UseVapiCallOptions } from './useVapiCall';\nimport { useVapiCall } from './useVapiCall';\nimport type { UseVapiChatOptions, ChatMessage } from './useVapiChat';\nimport { useVapiChat } from './useVapiChat';\nimport type { AssistantOverrides } from '../utils/vapiChatClient';\n\nexport type VapiMode = 'voice' | 'chat' | 'hybrid';\n\nexport interface UseVapiWidgetOptions {\n  mode: VapiMode;\n  publicKey: string;\n  assistantId?: string;\n  assistant?: any;\n  assistantOverrides?: AssistantOverrides;\n  apiUrl?: string;\n  firstChatMessage?: string;\n  voiceAutoReconnect?: boolean;\n  voiceReconnectStorage?: 'session' | 'cookies';\n  reconnectStorageKey?: string;\n  onCallStart?: () => void;\n  onCallEnd?: () => void;\n  onMessage?: (message: any) => void;\n  onError?: (error: Error) => void;\n}\n\nexport const useVapiWidget = ({\n  mode,\n  publicKey,\n  assistantId,\n  assistant,\n  assistantOverrides,\n  apiUrl,\n  firstChatMessage,\n  voiceAutoReconnect = false,\n  voiceReconnectStorage = 'session',\n  reconnectStorageKey,\n  onCallStart,\n  onCallEnd,\n  onMessage,\n  onError,\n}: UseVapiWidgetOptions) => {\n  const [activeMode, setActiveMode] = useState<'voice' | 'chat' | null>(null);\n  const [isUserTyping, setIsUserTyping] = useState(false);\n\n  const [voiceConversation, setVoiceConversation] = useState<ChatMessage[]>([]);\n\n  const buildCallOptions = (): any => {\n    // Priority: assistant object > assistantId with overrides > assistantId alone\n    if (assistant) {\n      return assistant;\n    }\n    if (assistantId) {\n      if (assistantOverrides) {\n        return {\n          assistantId,\n          assistantOverrides,\n        };\n      }\n      return assistantId;\n    }\n    return undefined;\n  };\n\n  // Voice call hook - only enabled in voice or hybrid mode\n  const voiceEnabled = mode === 'voice' || mode === 'hybrid';\n  const voice = useVapiCall({\n    publicKey,\n    callOptions: buildCallOptions(),\n    apiUrl,\n    enabled: voiceEnabled,\n    voiceAutoReconnect,\n    voiceReconnectStorage,\n    reconnectStorageKey,\n    onCallStart: () => {\n      // In hybrid mode, clear all conversations when starting voice\n      if (mode === 'hybrid') {\n        chat.clearMessages();\n        setVoiceConversation([]);\n      }\n      setActiveMode('voice');\n      setIsUserTyping(false);\n      onCallStart?.();\n    },\n    onCallEnd: () => {\n      setActiveMode(null);\n      onCallEnd?.();\n    },\n    onMessage,\n    onError,\n    onTranscript: (transcript) => {\n      const message: ChatMessage = {\n        role: transcript.role as 'user' | 'assistant',\n        content: transcript.text,\n        timestamp: transcript.timestamp,\n      };\n      setVoiceConversation((prev) => [...prev, message]);\n    },\n  } as UseVapiCallOptions);\n\n  // Chat only supports assistantId and assistantOverrides\n  const chatEnabled = mode === 'chat' || mode === 'hybrid';\n  const chat = useVapiChat({\n    enabled: chatEnabled,\n    publicKey: chatEnabled ? publicKey : undefined,\n    assistantId: chatEnabled ? assistantId : undefined,\n    assistantOverrides: chatEnabled ? assistantOverrides : undefined,\n    apiUrl,\n    onMessage, // Keep the callback for external notifications\n    onError,\n    firstChatMessage,\n  } as UseVapiChatOptions);\n\n  // Combine voice and chat conversations\n  const conversation =\n    mode === 'voice'\n      ? voiceConversation\n      : mode === 'chat'\n        ? chat.messages\n        : [...voiceConversation, ...chat.messages].sort(\n            (a, b) => a.timestamp.getTime() - b.timestamp.getTime()\n          );\n\n  // Handle chat input state for hybrid mode\n  const handleChatInput = useCallback((value: string) => {\n    setIsUserTyping(value.length > 0);\n    // Don't force mode switch just by typing\n  }, []);\n\n  const sendMessage = useCallback(\n    async (text: string, sessionEnd: boolean = false) => {\n      // In hybrid mode, switch to chat and clear all conversations only if switching from voice\n      if (mode === 'hybrid') {\n        if (voice.isCallActive) {\n          await voice.endCall({ force: true });\n        }\n        // Only clear conversations if we're switching from voice mode\n        if (activeMode !== 'chat') {\n          setVoiceConversation([]);\n          chat.clearMessages();\n        }\n        setActiveMode('chat');\n      }\n      await chat.sendMessage(text, sessionEnd);\n    },\n    [mode, chat, voice, activeMode]\n  );\n\n  const toggleCall = useCallback(\n    async ({ force }: { force?: boolean } = {}) => {\n      if (mode === 'hybrid' && !voice.isCallActive) {\n        // Clear all conversations when switching to voice\n        chat.clearMessages();\n        setVoiceConversation([]);\n        setActiveMode('voice');\n        setIsUserTyping(false);\n      }\n      await voice.toggleCall({ force });\n    },\n    [mode, voice, chat]\n  );\n\n  const clearConversation = useCallback(() => {\n    setVoiceConversation([]);\n    chat.clearMessages();\n    setActiveMode(null);\n    setIsUserTyping(false);\n  }, [chat]);\n\n  const isVoiceAvailable =\n    voiceEnabled && !voice.isCallActive && !chat.isLoading;\n  const isChatAvailable = chatEnabled && !chat.isLoading;\n\n  return {\n    // Current mode and state\n    mode,\n    activeMode,\n    conversation,\n\n    // Voice state and handlers\n    voice: {\n      ...voice,\n      isAvailable: isVoiceAvailable,\n      toggleCall,\n    },\n\n    // Chat state and handlers\n    chat: {\n      ...chat,\n      isAvailable: isChatAvailable,\n      sendMessage,\n      handleInput: handleChatInput,\n    },\n\n    // Combined handlers\n    clearConversation,\n    isUserTyping,\n  };\n};\n"],"names":["useVapiWidget","mode","publicKey","assistantId","assistant","assistantOverrides","apiUrl","firstChatMessage","voiceAutoReconnect","voiceReconnectStorage","reconnectStorageKey","onCallStart","onCallEnd","onMessage","onError","activeMode","setActiveMode","useState","isUserTyping","setIsUserTyping","voiceConversation","setVoiceConversation","buildCallOptions","voiceEnabled","voice","useVapiCall","chat","transcript","message","prev","chatEnabled","useVapiChat","conversation","a","b","handleChatInput","useCallback","value","sendMessage","text","sessionEnd","toggleCall","force","clearConversation","isVoiceAvailable","isChatAvailable"],"mappings":"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"}