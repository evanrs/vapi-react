{"version":3,"file":"useVapiCall.js","sources":["../../src/hooks/useVapiCall.ts"],"sourcesContent":["import { useState, useEffect, useRef, useCallback } from 'react';\nimport Vapi from '@vapi-ai/web';\nimport * as vapiCallStorage from '../utils/vapiCallStorage';\nimport type { StorageType } from '../utils/vapiCallStorage';\n\nexport interface VapiCallState {\n  isCallActive: boolean;\n  isSpeaking: boolean;\n  volumeLevel: number;\n  connectionStatus: 'disconnected' | 'connecting' | 'connected';\n  isMuted: boolean;\n}\n\nexport interface VapiCallHandlers {\n  startCall: () => Promise<void>;\n  endCall: (opts?: { force?: boolean }) => Promise<void>;\n  toggleCall: (opts?: { force?: boolean }) => Promise<void>;\n  toggleMute: () => void;\n  reconnect: () => Promise<void>;\n  clearStoredCall: () => void;\n}\n\nexport interface VapiCallInstance {\n  vapi: Vapi;\n}\n\nexport interface UseVapiCallOptions {\n  publicKey: string;\n  callOptions: any;\n  apiUrl?: string;\n  enabled?: boolean;\n  voiceAutoReconnect?: boolean;\n  voiceReconnectStorage?: StorageType;\n  reconnectStorageKey?: string;\n  onCallStart?: () => void;\n  onCallEnd?: () => void;\n  onMessage?: (message: any) => void;\n  onError?: (error: Error) => void;\n  onTranscript?: (transcript: {\n    role: string;\n    text: string;\n    timestamp: Date;\n  }) => void;\n}\n\nexport const useVapiCall = ({\n  publicKey,\n  callOptions,\n  apiUrl,\n  enabled = true,\n  voiceAutoReconnect = false,\n  voiceReconnectStorage = 'session',\n  reconnectStorageKey = 'vapi_widget_web_call',\n  onCallStart,\n  onCallEnd,\n  onMessage,\n  onError,\n  onTranscript,\n}: UseVapiCallOptions): VapiCallState & VapiCallHandlers & VapiCallInstance => {\n  const [vapi] = useState(() =>\n    publicKey ? new Vapi(publicKey, apiUrl) : null\n  );\n\n  const [isCallActive, setIsCallActive] = useState(false);\n  const [isSpeaking, setIsSpeaking] = useState(false);\n  const [isMuted, setIsMuted] = useState(false);\n  const [volumeLevel, setVolumeLevel] = useState(0);\n  const [connectionStatus, setConnectionStatus] = useState<\n    'disconnected' | 'connecting' | 'connected'\n  >('disconnected');\n\n  const callbacksRef = useRef({\n    onCallStart,\n    onCallEnd,\n    onMessage,\n    onError,\n    onTranscript,\n  });\n\n  useEffect(() => {\n    callbacksRef.current = {\n      onCallStart,\n      onCallEnd,\n      onMessage,\n      onError,\n      onTranscript,\n    };\n  });\n\n  useEffect(() => {\n    if (!vapi) {\n      return;\n    }\n\n    const handleCallStart = () => {\n      setIsCallActive(true);\n      setConnectionStatus('connected');\n      callbacksRef.current.onCallStart?.();\n    };\n\n    const handleCallEnd = () => {\n      setIsCallActive(false);\n      setConnectionStatus('disconnected');\n      setVolumeLevel(0);\n      setIsSpeaking(false);\n      setIsMuted(false);\n      // Clear stored call data on successful call end\n      vapiCallStorage.clearStoredCall(\n        reconnectStorageKey,\n        voiceReconnectStorage\n      );\n      callbacksRef.current.onCallEnd?.();\n    };\n\n    const handleSpeechStart = () => {\n      setIsSpeaking(true);\n    };\n\n    const handleSpeechEnd = () => {\n      setIsSpeaking(false);\n    };\n\n    const handleVolumeLevel = (volume: number) => {\n      setVolumeLevel(volume);\n    };\n\n    const handleMessage = (message: any) => {\n      if (message.type === 'transcript' && message.transcriptType === 'final') {\n        if (message.role === 'user' || message.role === 'assistant') {\n          callbacksRef.current.onTranscript?.({\n            role: message.role,\n            text: message.transcript,\n            timestamp: new Date(),\n          });\n        }\n      }\n\n      callbacksRef.current.onMessage?.(message);\n    };\n\n    const handleError = (error: Error) => {\n      console.error('Vapi error:', error);\n      setConnectionStatus('disconnected');\n      setIsCallActive(false);\n      setIsSpeaking(false);\n      callbacksRef.current.onError?.(error);\n    };\n\n    vapi.on('call-start', handleCallStart);\n    vapi.on('call-end', handleCallEnd);\n    vapi.on('speech-start', handleSpeechStart);\n    vapi.on('speech-end', handleSpeechEnd);\n    vapi.on('volume-level', handleVolumeLevel);\n    vapi.on('message', handleMessage);\n    vapi.on('error', handleError);\n\n    return () => {\n      vapi.removeListener('call-start', handleCallStart);\n      vapi.removeListener('call-end', handleCallEnd);\n      vapi.removeListener('speech-start', handleSpeechStart);\n      vapi.removeListener('speech-end', handleSpeechEnd);\n      vapi.removeListener('volume-level', handleVolumeLevel);\n      vapi.removeListener('message', handleMessage);\n      vapi.removeListener('error', handleError);\n    };\n  }, [vapi, reconnectStorageKey, voiceReconnectStorage]);\n\n  useEffect(() => {\n    return () => {\n      if (vapi) {\n        vapi.stop();\n      }\n    };\n  }, [vapi]);\n\n  const startCall = useCallback(async () => {\n    if (!vapi || !enabled) {\n      console.error('Cannot start call: no vapi instance or not enabled');\n      return;\n    }\n\n    try {\n      console.log('Starting call with configuration:', callOptions);\n      console.log('Starting call with options:', {\n        voiceAutoReconnect,\n      });\n      setConnectionStatus('connecting');\n      const call = await vapi.start(\n        // assistant\n        callOptions,\n        // assistant overrides,\n        undefined,\n        // squad\n        undefined,\n        // workflow\n        undefined,\n        // workflow overrides\n        undefined,\n        // options\n        {\n          roomDeleteOnUserLeaveEnabled: !voiceAutoReconnect,\n        }\n      );\n\n      // Store call data for reconnection if call was successful and auto-reconnect is enabled\n      if (call && voiceAutoReconnect) {\n        vapiCallStorage.storeCallData(\n          reconnectStorageKey,\n          call,\n          callOptions,\n          voiceReconnectStorage\n        );\n      }\n    } catch (error) {\n      console.error('Error starting call:', error);\n      setConnectionStatus('disconnected');\n      callbacksRef.current.onError?.(error as Error);\n    }\n  }, [\n    vapi,\n    callOptions,\n    enabled,\n    voiceAutoReconnect,\n    voiceReconnectStorage,\n    reconnectStorageKey,\n  ]);\n\n  const endCall = useCallback(\n    async ({ force = false }: { force?: boolean } = {}) => {\n      if (!vapi) {\n        console.log('Cannot end call: no vapi instance');\n        return;\n      }\n\n      console.log('Ending call with force:', force);\n      if (force) {\n        // end vapi call and delete daily room\n        vapi.end();\n      } else {\n        // simply disconnect from daily room\n        vapi.stop();\n      }\n    },\n    [vapi]\n  );\n\n  const toggleCall = useCallback(\n    async ({ force = false }: { force?: boolean } = {}) => {\n      if (isCallActive) {\n        await endCall({ force });\n      } else {\n        await startCall();\n      }\n    },\n    [isCallActive, startCall, endCall]\n  );\n\n  const toggleMute = useCallback(() => {\n    if (!vapi || !isCallActive) {\n      console.log('Cannot toggle mute: no vapi instance or call not active');\n      return;\n    }\n\n    const newMutedState = !isMuted;\n    vapi.setMuted(newMutedState);\n    setIsMuted(newMutedState);\n  }, [vapi, isCallActive, isMuted]);\n\n  const reconnect = useCallback(async () => {\n    if (!vapi || !enabled) {\n      console.error('Cannot reconnect: no vapi instance or not enabled');\n      return;\n    }\n\n    const storedData = vapiCallStorage.getStoredCallData(\n      reconnectStorageKey,\n      voiceReconnectStorage\n    );\n\n    if (!storedData) {\n      console.warn('No stored call data found for reconnection');\n      return;\n    }\n\n    // Check if callOptions match before reconnecting\n    if (\n      !vapiCallStorage.areCallOptionsEqual(storedData.callOptions, callOptions)\n    ) {\n      console.warn(\n        'CallOptions have changed since last call, clearing stored data and skipping reconnection'\n      );\n      vapiCallStorage.clearStoredCall(\n        reconnectStorageKey,\n        voiceReconnectStorage\n      );\n      return;\n    }\n\n    setConnectionStatus('connecting');\n\n    try {\n      await vapi.reconnect({\n        webCallUrl: storedData.webCallUrl,\n        id: storedData.id,\n        artifactPlan: storedData.artifactPlan,\n        assistant: storedData.assistant,\n      });\n      console.log('Successfully reconnected to call');\n    } catch (error) {\n      setConnectionStatus('disconnected');\n      console.error('Reconnection failed:', error);\n      vapiCallStorage.clearStoredCall(\n        reconnectStorageKey,\n        voiceReconnectStorage\n      );\n      callbacksRef.current.onError?.(error as Error);\n    }\n  }, [vapi, enabled, reconnectStorageKey, voiceReconnectStorage, callOptions]);\n\n  const clearStoredCall = useCallback(() => {\n    vapiCallStorage.clearStoredCall(reconnectStorageKey, voiceReconnectStorage);\n  }, [reconnectStorageKey, voiceReconnectStorage]);\n\n  useEffect(() => {\n    if (!vapi || !enabled || !voiceAutoReconnect) {\n      return;\n    }\n    reconnect();\n  }, [vapi, enabled, voiceAutoReconnect, reconnect, reconnectStorageKey]);\n\n  return {\n    // State\n    isCallActive,\n    isSpeaking,\n    volumeLevel,\n    connectionStatus,\n    isMuted,\n    // Handlers\n    startCall,\n    endCall,\n    toggleCall,\n    toggleMute,\n    reconnect,\n    clearStoredCall,\n    // Instance\n    vapi: vapi!,\n  };\n};\n"],"names":["useVapiCall","publicKey","callOptions","apiUrl","enabled","voiceAutoReconnect","voiceReconnectStorage","reconnectStorageKey","onCallStart","onCallEnd","onMessage","onError","onTranscript","vapi","useState","Vapi","isCallActive","setIsCallActive","isSpeaking","setIsSpeaking","isMuted","setIsMuted","volumeLevel","setVolumeLevel","connectionStatus","setConnectionStatus","callbacksRef","useRef","useEffect","handleCallStart","handleCallEnd","vapiCallStorage.clearStoredCall","handleSpeechStart","handleSpeechEnd","handleVolumeLevel","volume","handleMessage","message","handleError","error","startCall","useCallback","call","vapiCallStorage.storeCallData","endCall","force","toggleCall","toggleMute","newMutedState","reconnect","storedData","vapiCallStorage.getStoredCallData","vapiCallStorage.areCallOptionsEqual","clearStoredCall"],"mappings":"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"}